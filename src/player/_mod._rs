
use avian3d::prelude::*;
use bevy::{color::palettes::tailwind, log, prelude::*};
use leafwing_input_manager::prelude::*;

const MOVE_AND_SLIDE_MAX_ITERATIONS: usize = 8;

pub struct PlayerPlugin;

impl Plugin for PlayerPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(InputManagerPlugin::<Action>::default());

        app.add_observer(on_spawn_player);
        app.add_systems(FixedPostUpdate, (movement, move_and_slide));
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum Action {
    #[actionlike(DualAxis)]
    Move,
    Jump,
}

#[derive(Component)]
#[require(Collider, LinearVelocity)]
pub struct Player {
    speed: f32,
}

impl Default for Player {
    fn default() -> Self {
        Self { speed: 3.0 }
    }
}

#[derive(Component)]
struct Grounded;

#[derive(Event)]
pub struct SpawnPlayer {
    pub transform: Transform,
}

fn on_spawn_player(
    trigger: Trigger<SpawnPlayer>,
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let mut input_map = InputMap::default()
        .with_dual_axis(Action::Move, GamepadStick::LEFT)
        .with_dual_axis(Action::Move, VirtualDPad::wasd());
    input_map.insert(Action::Jump, GamepadButton::East);
    input_map.insert(Action::Jump, KeyCode::Space);

    let transform = trigger.event().transform;
    let mesh = meshes.add(Capsule3d::new(0.5, 2.0));
    let material = materials.add(StandardMaterial {
        base_color: tailwind::RED_400.into(),
        ..Default::default()
    });
    commands.spawn((
        Player::default(),
        InputManagerBundle::with_map(input_map),
        transform,
        Mesh3d(mesh.clone()),
        MeshMaterial3d(material.clone()),
        RigidBody::Kinematic,
        Collider::capsule(0.5, 2.0),
    ));
}

fn movement(
    mut commands: Commands,
    mut player: Query<
        (
            &Player,
            &Transform,
            &mut LinearVelocity,
            &ActionState<Action>,
        ),
        With<Player>,
    >,
) {
    if let Ok((player, transform, mut velocity, input)) = player.get_single_mut() {
        let input_direction = input.clamped_axis_pair(&Action::Move).normalize();
        let move_direction =
            transform.rotation * Vec3::new(input_direction.x, 0.0, input_direction.y);
        velocity.0 = move_direction * player.speed;
    }
}

fn move_and_slide(
    mut player: Query<(&Transform, &mut LinearVelocity, &Collider), With<Player>>,
    spatial_query: SpatialQuery,
) {
    if let Ok((transform, mut velocity, collider)) = player.get_single_mut() {
        if velocity.0.length_squared() == 0.0 {
            return;
        }

        let mut distance_to_travel = velocity.0.length();
        let mut direction = velocity.0.normalize();

        let mut slide_position = transform.translation;
        let mut i = 0;
        while distance_to_travel > 0.0 && i < MOVE_AND_SLIDE_MAX_ITERATIONS {
            if let Some(hit) = spatial_query.cast_shape(
                collider,
                slide_position,
                transform.rotation,
                Dir3::new(direction).unwrap(),
                &ShapeCastConfig {
                    max_distance: distance_to_travel,
                    ..Default::default()
                },
                &SpatialQueryFilter::default(),
            ) {
                let hit_position = slide_position + direction * hit.distance;
                direction =
                    (direction + hit.normal1 * hit.normal1.dot(direction).abs()).normalize();
                distance_to_travel -= hit.distance;

                slide_position = hit_position + direction * distance_to_travel;
                i += 1;
            }
        }

        velocity.0 = slide_position - transform.translation;
    }
}
